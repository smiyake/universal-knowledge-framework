"""
Obsidian Bridge Adapter - ObsidianÈÄ£Êê∫„Ç¢„ÉÄ„Éó„Çø„Éº
Obsidian Integration Adapter for Universal Knowledge Framework
"""

import json
import shutil
from pathlib import Path
from typing import Dict, Any, Optional, List
from datetime import datetime

from .bridge import ToolAdapter, StandardProjectData


class ObsidianAdapter(ToolAdapter):
    """
    ObsidianÁî®„Éñ„É™„ÉÉ„Ç∏„Ç¢„ÉÄ„Éó„Çø„Éº
    Obsidian„Éú„É´„Éà„Å®„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éá„Éº„Çø„ÅÆÂêåÊúü„ÇíË°å„ÅÜ
    """
    
    def __init__(self):
        super().__init__("obsidian")
        self.vault_path: Optional[Path] = None
        self.project_path: Optional[Path] = None
        self.obsidian_config_path: Optional[Path] = None
    
    def connect(self, config: Dict[str, Any]) -> bool:
        """
        Obsidian„Éú„É´„Éà„Å´Êé•Á∂ö
        
        Args:
            config: Êé•Á∂öË®≠ÂÆö
                - vault_path: „Éú„É´„Éà„Éë„Çπ
                - project_path: „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éë„Çπ
                - create_if_missing: „Éú„É´„Éà„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà‰ΩúÊàê„Åô„Çã„Åã
                
        Returns:
            bool: Êé•Á∂öÊàêÂäüÂèØÂê¶
        """
        try:
            vault_path = config.get('vault_path')
            project_path = config.get('project_path', Path.cwd())
            create_if_missing = config.get('create_if_missing', True)
            
            if not vault_path:
                # „Éá„Éï„Ç©„É´„Éà„Éú„É´„Éà„Éë„ÇπÔºà„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂÜÖ„ÅÆknowledge„Éá„Ç£„É¨„ÇØ„Éà„É™Ôºâ
                vault_path = Path(project_path) / "knowledge"
            
            self.vault_path = Path(vault_path)
            self.project_path = Path(project_path)
            self.obsidian_config_path = self.vault_path / ".obsidian"
            
            # „Éú„É´„Éà„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆÁ¢∫Ë™ç„Éª‰ΩúÊàê
            if not self.vault_path.exists() and create_if_missing:
                self.vault_path.mkdir(parents=True, exist_ok=True)
                self._initialize_obsidian_vault()
            elif not self.vault_path.exists():
                return False
            
            # .obsidian„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆÁ¢∫Ë™ç„Éª‰ΩúÊàê
            if not self.obsidian_config_path.exists() and create_if_missing:
                self._initialize_obsidian_vault()
            
            self._config = config
            self._connected = True
            
            print(f"‚úÖ Obsidian„Éú„É´„Éà„Å´Êé•Á∂ö„Åó„Åæ„Åó„Åü: {self.vault_path}")
            return True
            
        except Exception as e:
            print(f"‚ùå ObsidianÊé•Á∂ö„Ç®„É©„Éº: {e}")
            return False
    
    def disconnect(self) -> bool:
        """
        Obsidian„Éú„É´„Éà„Åã„ÇâÂàáÊñ≠
        
        Returns:
            bool: ÂàáÊñ≠ÊàêÂäüÂèØÂê¶
        """
        try:
            self.vault_path = None
            self.project_path = None
            self.obsidian_config_path = None
            self._connected = False
            self._config = {}
            
            print("‚úÖ Obsidian„Éú„É´„Éà„Åã„ÇâÂàáÊñ≠„Åó„Åæ„Åó„Åü")
            return True
            
        except Exception as e:
            print(f"‚ùå ObsidianÂàáÊñ≠„Ç®„É©„Éº: {e}")
            return False
    
    def is_connected(self) -> bool:
        """
        Êé•Á∂öÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
        
        Returns:
            bool: Êé•Á∂öÁä∂ÊÖã
        """
        return (self._connected and 
                self.vault_path is not None and 
                self.vault_path.exists() and
                self.obsidian_config_path is not None and
                self.obsidian_config_path.exists())
    
    def sync_data(self, project_data: StandardProjectData) -> bool:
        """
        „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éá„Éº„Çø„ÇíObsidian„Éú„É´„Éà„Å´ÂêåÊúü
        
        Args:
            project_data: ÂêåÊúü„Åô„Çã„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éá„Éº„Çø
            
        Returns:
            bool: ÂêåÊúüÊàêÂäüÂèØÂê¶
        """
        if not self.is_connected():
            return False
        
        try:
            # „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊ¶ÇË¶Å„Éï„Ç°„Ç§„É´‰ΩúÊàê/Êõ¥Êñ∞
            self._sync_project_overview(project_data)
            
            # „Çø„Çπ„ÇØ„Éï„Ç°„Ç§„É´‰ΩúÊàê/Êõ¥Êñ∞
            self._sync_tasks(project_data)
            
            # „Éï„Ç°„Ç§„É´ÊßãÈÄ†„Éû„ÉÉ„Éó‰ΩúÊàê/Êõ¥Êñ∞
            self._sync_file_structure(project_data)
            
            # „É°„Çø„Éá„Éº„ÇøÂêåÊúü
            self._sync_metadata(project_data)
            
            print(f"‚úÖ Obsidian„Éú„É´„Éà„Å´ÂêåÊúüÂÆå‰∫Ü: {len(project_data.files)}„Éï„Ç°„Ç§„É´")
            return True
            
        except Exception as e:
            print(f"‚ùå ObsidianÂêåÊúü„Ç®„É©„Éº: {e}")
            return False
    
    def export_data(self) -> Optional[StandardProjectData]:
        """
        Obsidian„Éú„É´„Éà„Åã„Çâ„Éá„Éº„Çø„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà
        
        Returns:
            Optional[StandardProjectData]: „Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åï„Çå„Åü„Éá„Éº„Çø
        """
        if not self.is_connected():
            return None
        
        try:
            # „Éú„É´„ÉàÂÜÖ„ÅÆ„Éï„Ç°„Ç§„É´ÊÉÖÂ†±ÂèéÈõÜ
            files = []
            for file_path in self.vault_path.rglob("*.md"):
                if not any(part.startswith('.') for part in file_path.parts):
                    relative_path = file_path.relative_to(self.vault_path)
                    files.append({
                        "path": str(relative_path),
                        "size": file_path.stat().st_size,
                        "modified": datetime.fromtimestamp(file_path.stat().st_mtime).isoformat()
                    })
            
            # „Çø„Çπ„ÇØÊÉÖÂ†±Ë™≠„ÅøËæº„Åø
            tasks = self._load_tasks_from_vault()
            
            # „É°„Çø„Éá„Éº„ÇøË™≠„ÅøËæº„Åø
            metadata = self._load_metadata_from_vault()
            
            return StandardProjectData(
                name=metadata.get('name', self.vault_path.name),
                description=metadata.get('description', ''),
                path=str(self.project_path) if self.project_path else str(self.vault_path),
                type=metadata.get('type', 'obsidian'),
                created_at=metadata.get('created_at', datetime.now().isoformat()),
                last_modified=datetime.now().isoformat(),
                metadata=metadata,
                files=files,
                tasks=tasks,
                tags=metadata.get('tags', [])
            )
            
        except Exception as e:
            print(f"‚ùå Obsidian„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Ç®„É©„Éº: {e}")
            return None
    
    def import_data(self, data: StandardProjectData) -> bool:
        """
        StandardProjectData„ÇíObsidian„Éú„É´„Éà„Å´„Ç§„É≥„Éù„Éº„Éà
        
        Args:
            data: „Ç§„É≥„Éù„Éº„Éà„Åô„Çã„Éá„Éº„Çø
            
        Returns:
            bool: „Ç§„É≥„Éù„Éº„ÉàÊàêÂäüÂèØÂê¶
        """
        if not self.is_connected():
            return False
        
        return self.sync_data(data)
    
    def get_tool_info(self) -> Dict[str, Any]:
        """
        Obsidian„ÉÑ„Éº„É´ÊÉÖÂ†±„ÇíÂèñÂæó
        
        Returns:
            Dict[str, Any]: „ÉÑ„Éº„É´ÊÉÖÂ†±
        """
        info = {
            "name": "Obsidian",
            "type": "knowledge_management",
            "version": "1.0.0",
            "adapter_version": "1.0.0",
            "supported_formats": ["markdown", "json"],
            "features": [
                "note_taking",
                "linking",
                "graph_view",
                "task_management"
            ]
        }
        
        if self.is_connected():
            info.update({
                "vault_path": str(self.vault_path),
                "project_path": str(self.project_path),
                "connected": True,
                "vault_exists": self.vault_path.exists(),
                "config_exists": self.obsidian_config_path.exists()
            })
        else:
            info["connected"] = False
        
        return info
    
    def _initialize_obsidian_vault(self) -> None:
        """Obsidian„Éú„É´„Éà„ÇíÂàùÊúüÂåñ"""
        try:
            # .obsidian„Éá„Ç£„É¨„ÇØ„Éà„É™‰ΩúÊàê
            self.obsidian_config_path.mkdir(parents=True, exist_ok=True)
            
            # Âü∫Êú¨Ë®≠ÂÆö„Éï„Ç°„Ç§„É´‰ΩúÊàê
            self._create_obsidian_config()
            
            # „Éú„É´„ÉàÁî®„Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÈÄ†‰ΩúÊàê
            self._create_vault_structure()
            
            print(f"üìÅ Obsidian„Éú„É´„Éà„ÇíÂàùÊúüÂåñ„Åó„Åæ„Åó„Åü: {self.vault_path}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Obsidian„Éú„É´„ÉàÂàùÊúüÂåñ„Ç®„É©„Éº: {e}")
    
    def _create_obsidian_config(self) -> None:
        """ObsidianË®≠ÂÆö„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê"""
        # app.json
        app_config = {
            "legacyEditor": False,
            "livePreview": True,
            "defaultViewMode": "source",
            "theme": "obsidian",
            "translucency": False,
            "alwaysUpdateLinks": True
        }
        
        with open(self.obsidian_config_path / "app.json", "w", encoding="utf-8") as f:
            json.dump(app_config, f, indent=2, ensure_ascii=False)
        
        # workspace.json
        workspace_config = {
            "main": {
                "id": "main",
                "type": "split",
                "children": [
                    {
                        "id": "editor",
                        "type": "leaf",
                        "state": {
                            "type": "markdown",
                            "state": {
                                "file": "00_Overview/„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊ¶ÇË¶Å.md",
                                "mode": "source"
                            }
                        }
                    }
                ]
            },
            "left": {
                "id": "left",
                "type": "split",
                "children": [
                    {
                        "id": "file-explorer",
                        "type": "leaf",
                        "state": {
                            "type": "file-explorer",
                            "state": {}
                        }
                    }
                ],
                "collapsed": False
            },
            "right": {
                "id": "right",
                "type": "split",
                "children": [
                    {
                        "id": "outline",
                        "type": "leaf",
                        "state": {
                            "type": "outline",
                            "state": {}
                        }
                    }
                ],
                "collapsed": False
            },
            "active": "editor",
            "lastOpenFiles": ["00_Overview/„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊ¶ÇË¶Å.md"]
        }
        
        with open(self.obsidian_config_path / "workspace.json", "w", encoding="utf-8") as f:
            json.dump(workspace_config, f, indent=2, ensure_ascii=False)
    
    def _create_vault_structure(self) -> None:
        """„Éú„É´„ÉàÁî®„Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÈÄ†„Çí‰ΩúÊàê"""
        directories = [
            "00_Overview",
            "01_Requirements",
            "02_Design", 
            "03_Implementation",
            "04_Testing",
            "05_Deployment",
            "99_Archives"
        ]
        
        for dir_name in directories:
            (self.vault_path / dir_name).mkdir(exist_ok=True)
    
    def _sync_project_overview(self, project_data: StandardProjectData) -> None:
        """„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊ¶ÇË¶Å„ÇíÂêåÊúü"""
        overview_dir = self.vault_path / "00_Overview"
        overview_dir.mkdir(exist_ok=True)
        
        overview_content = f"""# {project_data.name}

## „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊ¶ÇË¶Å
{project_data.description}

## Âü∫Êú¨ÊÉÖÂ†±
- **„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Çø„Ç§„Éó**: {project_data.type}
- **‰ΩúÊàêÊó•**: {project_data.created_at[:10]}
- **ÊúÄÁµÇÊõ¥Êñ∞**: {project_data.last_modified[:10]}
- **„Éï„Ç°„Ç§„É´Êï∞**: {len(project_data.files)}

## „Çø„Ç∞
{' '.join(f'#{tag}' for tag in project_data.tags) if project_data.tags else '„Å™„Åó'}

## Èñ¢ÈÄ£„É™„É≥„ÇØ
- [[„Çø„Çπ„ÇØÁÆ°ÁêÜ]] - „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Çø„Çπ„ÇØ„ÅÆ‰∏ÄË¶ß
- [[„Éï„Ç°„Ç§„É´ÊßãÈÄ†]] - „Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éï„Ç°„Ç§„É´ÊßãÈÄ†
- [[ÈÄ≤ÊçóÁÆ°ÁêÜ]] - ÈñãÁô∫ÈÄ≤Êçó„ÅÆËøΩË∑°

---
*„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅØ Universal Knowledge Framework „Å´„Çà„ÇäËá™ÂãïÁîüÊàê„Åï„Çå„Åæ„Åó„Åü*
*ÊúÄÁµÇÂêåÊúü: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        
        with open(overview_dir / "„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊ¶ÇË¶Å.md", "w", encoding="utf-8") as f:
            f.write(overview_content)
    
    def _sync_tasks(self, project_data: StandardProjectData) -> None:
        """„Çø„Çπ„ÇØ„ÇíÂêåÊúü"""
        tasks_dir = self.vault_path / "03_Implementation"
        tasks_dir.mkdir(exist_ok=True)
        
        if not project_data.tasks:
            tasks_content = """# „Çø„Çπ„ÇØÁÆ°ÁêÜ

## ÁèæÂú®„ÅÆ„Çø„Çπ„ÇØ
„Çø„Çπ„ÇØ„ÅØ„Åæ„Å†ÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ

## ÂÆå‰∫Ü„Åó„Åü„Çø„Çπ„ÇØ
„Å™„Åó

---
*„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅØ Universal Knowledge Framework „Å´„Çà„ÇäËá™ÂãïÁîüÊàê„Åï„Çå„Åæ„Åó„Åü*
"""
        else:
            pending_tasks = [t for t in project_data.tasks if t.get('status') == 'pending']
            in_progress_tasks = [t for t in project_data.tasks if t.get('status') == 'in_progress']
            completed_tasks = [t for t in project_data.tasks if t.get('status') == 'completed']
            
            tasks_content = f"""# „Çø„Çπ„ÇØÁÆ°ÁêÜ

## ÈÄ≤Ë°å‰∏≠„ÅÆ„Çø„Çπ„ÇØ
{self._format_tasks(in_progress_tasks) if in_progress_tasks else 'ÁèæÂú®ÈÄ≤Ë°å‰∏≠„ÅÆ„Çø„Çπ„ÇØ„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì'}

## ÂæÖÊ©ü‰∏≠„ÅÆ„Çø„Çπ„ÇØ
{self._format_tasks(pending_tasks) if pending_tasks else 'ÂæÖÊ©ü‰∏≠„ÅÆ„Çø„Çπ„ÇØ„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì'}

## ÂÆå‰∫Ü„Åó„Åü„Çø„Çπ„ÇØ
{self._format_tasks(completed_tasks) if completed_tasks else 'ÂÆå‰∫Ü„Åó„Åü„Çø„Çπ„ÇØ„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì'}

---
*„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅØ Universal Knowledge Framework „Å´„Çà„ÇäËá™ÂãïÁîüÊàê„Åï„Çå„Åæ„Åó„Åü*
*ÊúÄÁµÇÂêåÊúü: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        
        with open(tasks_dir / "„Çø„Çπ„ÇØÁÆ°ÁêÜ.md", "w", encoding="utf-8") as f:
            f.write(tasks_content)
    
    def _sync_file_structure(self, project_data: StandardProjectData) -> None:
        """„Éï„Ç°„Ç§„É´ÊßãÈÄ†„ÇíÂêåÊúü"""
        overview_dir = self.vault_path / "00_Overview"
        overview_dir.mkdir(exist_ok=True)
        
        # „Éï„Ç°„Ç§„É´„ÇíÁ®ÆÈ°ûÂà•„Å´ÂàÜÈ°û
        file_categories = {}
        for file_info in project_data.files:
            ext = Path(file_info["path"]).suffix.lower()
            if ext not in file_categories:
                file_categories[ext] = []
            file_categories[ext].append(file_info)
        
        structure_content = f"""# „Éï„Ç°„Ç§„É´ÊßãÈÄ†

## Ê¶ÇË¶Å
- **Á∑è„Éï„Ç°„Ç§„É´Êï∞**: {len(project_data.files)}
- **„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éë„Çπ**: `{project_data.path}`

## „Éï„Ç°„Ç§„É´Á®ÆÂà•
"""
        
        for ext, files in sorted(file_categories.items()):
            ext_name = ext if ext else "Êã°ÂºµÂ≠ê„Å™„Åó"
            structure_content += f"\n### {ext_name} ({len(files)}„Éï„Ç°„Ç§„É´)\n"
            
            for file_info in sorted(files, key=lambda x: x["path"])[:10]:  # ÊúÄÂ§ß10„Éï„Ç°„Ç§„É´Ë°®Á§∫
                size_kb = file_info["size"] / 1024
                structure_content += f"- `{file_info['path']}` ({size_kb:.1f}KB)\n"
            
            if len(files) > 10:
                structure_content += f"- ... „Åù„ÅÆ‰ªñ {len(files) - 10} „Éï„Ç°„Ç§„É´\n"
        
        structure_content += f"""
---
*„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅØ Universal Knowledge Framework „Å´„Çà„ÇäËá™ÂãïÁîüÊàê„Åï„Çå„Åæ„Åó„Åü*
*ÊúÄÁµÇÂêåÊúü: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        
        with open(overview_dir / "„Éï„Ç°„Ç§„É´ÊßãÈÄ†.md", "w", encoding="utf-8") as f:
            f.write(structure_content)
    
    def _sync_metadata(self, project_data: StandardProjectData) -> None:
        """„É°„Çø„Éá„Éº„Çø„ÇíÂêåÊúü"""
        metadata_file = self.obsidian_config_path / "ukf-metadata.json"
        
        metadata = {
            "project_data": project_data.to_dict(),
            "sync_info": {
                "last_sync": datetime.now().isoformat(),
                "sync_source": "universal-knowledge-framework",
                "adapter_version": "1.0.0"
            }
        }
        
        with open(metadata_file, "w", encoding="utf-8") as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
    
    def _format_tasks(self, tasks: List[Dict[str, Any]]) -> str:
        """„Çø„Çπ„ÇØ„ÇíMarkdownÂΩ¢Âºè„Åß„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        if not tasks:
            return "„Å™„Åó"
        
        formatted = ""
        for task in tasks:
            priority_emoji = {
                'high': 'üî¥',
                'medium': 'üü°', 
                'low': 'üü¢'
            }.get(task.get('priority', 'medium'), '‚ö™')
            
            status_emoji = {
                'pending': '‚è≥',
                'in_progress': 'üîÑ',
                'completed': '‚úÖ'
            }.get(task.get('status', 'pending'), '‚ùì')
            
            formatted += f"- {status_emoji} {priority_emoji} {task.get('content', '')}\n"
        
        return formatted
    
    def _load_tasks_from_vault(self) -> List[Dict[str, Any]]:
        """„Éú„É´„Éà„Åã„Çâ„Çø„Çπ„ÇØÊÉÖÂ†±„ÇíË™≠„ÅøËæº„Åø"""
        try:
            metadata_file = self.obsidian_config_path / "ukf-metadata.json"
            if metadata_file.exists():
                with open(metadata_file, "r", encoding="utf-8") as f:
                    metadata = json.load(f)
                return metadata.get("project_data", {}).get("tasks", [])
        except Exception:
            pass
        return []
    
    def _load_metadata_from_vault(self) -> Dict[str, Any]:
        """„Éú„É´„Éà„Åã„Çâ„É°„Çø„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø"""
        try:
            metadata_file = self.obsidian_config_path / "ukf-metadata.json"
            if metadata_file.exists():
                with open(metadata_file, "r", encoding="utf-8") as f:
                    metadata = json.load(f)
                return metadata.get("project_data", {}).get("metadata", {})
        except Exception:
            pass
        return {}